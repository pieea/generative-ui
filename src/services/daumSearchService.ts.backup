import * as cheerio from 'cheerio';
import type { AnyNode } from 'domhandler';
import OpenAI from 'openai';
import { SearchIntent } from './queryRewriteService';
import { SearchResultItem } from '@/types';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// 다음 검색 결과 컴포넌트
export interface DaumSearchComponent {
  type: string;
  title: string;
  items: SearchResultItem[];
  raw: string;
}

// 검색 엔진 분석 결과
export interface SearchEngineAnalysis {
  query: string;
  components: DaumSearchComponent[];
  allItems: SearchResultItem[];
  llmExtractedItems: SearchResultItem[];  // LLM이 추출한 구조화 데이터
  primaryIntent: SearchIntent;
  secondaryIntent?: SearchIntent;
  reasoning: string;
}

// 다음 검색 URL 생성
function buildDaumSearchUrl(query: string): string {
  const encodedQuery = encodeURIComponent(query);
  return `https://search.daum.net/search?w=tot&nil_mtopsearch=btn&DA=YZR&q=${encodedQuery}`;
}

// 다음 이미지 검색 URL 생성
function buildDaumImageSearchUrl(query: string): string {
  const encodedQuery = encodeURIComponent(query);
  return `https://search.daum.net/search?w=img&nil_search=btn&DA=NTB&enc=utf8&q=${encodedQuery}`;
}

// disp-attr -> intent 매핑
const DISP_ATTR_INTENT_MAP: Record<string, string> = {
  'IIM': 'images',      // 이미지
  'SNP': 'products',    // 쇼핑하우
  'SNY': 'products',    // 쇼핑
  '0NS': 'products',    // 네이버쇼핑
  'NSJ': 'products',    // 쇼핑 (새 형식)
  '0SC': 'products',    // 쇼핑 컬렉션
  'DNS': 'news',        // 뉴스
  'PRF': 'people',      // 인물 프로필
  'Z6T': 'exchange',    // 환율
  '3DV': 'country',     // 국가 정보
  'TCS': 'events',      // 통합 컬렉션 (축제/일정)
  'VOI': 'videos',      // 동영상
  'TWA': 'web',         // 통합웹
  'TWD': 'web',         // 통합웹
  '0NL': 'ads',         // 파워링크 광고 (무시)
};

// disp-attr 우선순위 (낮을수록 높은 우선순위)
// 특정 의도는 위치에 관계없이 우선순위를 가질 수 있음
const DISP_ATTR_PRIORITY: Record<string, number> = {
  'Z6T': 0,   // 환율 - 최우선 (있으면 무조건)
  '3DV': 1,   // 국가 정보 - 높은 우선순위
  'PRF': 2,   // 인물 프로필
  'TCS': 3,   // 통합 컬렉션
  'IIM': 10,  // 이미지 - 위치 기반
  'SNP': 10,  // 쇼핑 - 위치 기반
  'SNY': 10,
  '0NS': 10,
  'NSJ': 10,  // 쇼핑 (새 형식) - 위치 기반
  '0SC': 10,  // 쇼핑 컬렉션 - 위치 기반
  'DNS': 10,  // 뉴스 - 위치 기반
  'VOI': 10,  // 동영상 - 위치 기반
};

// 상위 컴포넌트에서 주요 의도 판단
interface TopComponentAnalysis {
  primaryIntent: string;
  dispAttr: string;
  position: number;
  reasoning: string;
}

function analyzeTopComponents(html: string, query?: string): TopComponentAnalysis | null {
  const $ = cheerio.load(html);
  const topComponents: { dispAttr: string; position: number; priority: number }[] = [];

  // 상위 5개 g_comp에서 disp-attr 추출
  $('.g_comp').slice(0, 5).each((index, element) => {
    const dispAttr = $(element).attr('disp-attr') || '';
    if (dispAttr && DISP_ATTR_INTENT_MAP[dispAttr]) {
      const priority = DISP_ATTR_PRIORITY[dispAttr] ?? 100;
      topComponents.push({ dispAttr, position: index, priority });
    }
  });

  if (topComponents.length === 0) {
    return null;
  }

  console.log('[Daum Search] Top disp-attr components:', topComponents.map(c => `[${c.position}] ${c.dispAttr}`).join(', '));

  // 이미지 의도 쿼리 감지 (사진, 이미지, 화보, 그림 등)
  const imageKeywords = ['사진', '이미지', '화보', '그림', '포토', '움짤', 'gif', '사진첩'];
  const isImageQuery = query && imageKeywords.some(kw => query.toLowerCase().includes(kw));

  // 이미지 의도 쿼리인데 IIM이 상위 3개 내에 있으면 IIM 우선
  if (isImageQuery) {
    const iimComponent = topComponents.find(c => c.dispAttr === 'IIM' && c.position <= 2);
    if (iimComponent) {
      console.log(`[Daum Search] Image query detected, prioritizing IIM at position ${iimComponent.position}`);
      return {
        primaryIntent: 'images',
        dispAttr: 'IIM',
        position: iimComponent.position,
        reasoning: `이미지 검색 쿼리 감지 - IIM 컴포넌트 우선 적용 (position ${iimComponent.position})`,
      };
    }
  }

  // 정렬: 우선순위 > 위치
  // 우선순위가 낮은 것(높은 priority)이 위치 기반이면, 상위 3개 내에서만 고려
  topComponents.sort((a, b) => {
    // 절대 우선순위가 있는 것 (priority < 10) 먼저
    if (a.priority < 10 && b.priority >= 10) return -1;
    if (b.priority < 10 && a.priority >= 10) return 1;

    // 둘 다 절대 우선순위가 있으면 priority로
    if (a.priority < 10 && b.priority < 10) {
      return a.priority - b.priority;
    }

    // 둘 다 위치 기반이면 상위 3개 내에서 위치로 판단
    if (a.position <= 2 && b.position <= 2) {
      return a.position - b.position;
    }

    // 상위 3개 안에 있는 것 우선
    if (a.position <= 2 && b.position > 2) return -1;
    if (b.position <= 2 && a.position > 2) return 1;

    return a.position - b.position;
  });

  const winner = topComponents[0];
  const intent = DISP_ATTR_INTENT_MAP[winner.dispAttr];

  const reasoning = winner.priority < 10
    ? `${winner.dispAttr} 컴포넌트가 절대 우선순위로 ${intent} 의도 결정`
    : `${winner.dispAttr} 컴포넌트가 위치 ${winner.position}에서 ${intent} 의도 결정`;

  console.log(`[Daum Search] Primary intent: ${intent} (${reasoning})`);

  return {
    primaryIntent: intent,
    dispAttr: winner.dispAttr,
    position: winner.position,
    reasoning,
  };
}

// 다음 검색 결과 HTML 가져오기
async function fetchDaumSearchHtml(query: string): Promise<string> {
  const url = buildDaumSearchUrl(query);
  console.log('[Daum Search] Fetching:', url);

  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.text();
  } catch (error) {
    console.error('[Daum Search] Fetch error:', error);
    throw error;
  }
}

// 다음 이미지 검색 결과 HTML 가져오기
async function fetchDaumImageSearchHtml(query: string): Promise<string> {
  const url = buildDaumImageSearchUrl(query);
  console.log('[Daum Image Search] Fetching:', url);

  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.text();
  } catch (error) {
    console.error('[Daum Image Search] Fetch error:', error);
    throw error;
  }
}

// JavaScript 객체 리터럴을 JSON으로 변환 (unquoted keys -> quoted keys)
function jsObjToJson(jsObj: string): string {
  // 작은따옴표를 큰따옴표로 변환
  let result = jsObj.replace(/'/g, '"');
  // unquoted property names에 따옴표 추가 (예: ndid64: -> "ndid64":)
  result = result.replace(/([{,]\s*)(\w+)\s*:/g, '$1"$2":');
  // 후행 쉼표 제거
  result = result.replace(/,\s*([}\]])/g, '$1');
  // HTML 엔티티 처리
  result = result.replace(/&gt;/g, '>').replace(/&lt;/g, '<');
  // 이스케이프되지 않은 슬래시 처리
  result = result.replace(/<\\\/b>/g, '');
  return result;
}

// 다음 이미지 검색 결과에서 이미지 데이터 추출 (JavaScript initialData 파싱)
function extractImageItemsFromHtml(html: string): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  try {
    // JavaScript 내 initialData 배열 찾기
    let imageData: Array<{
      url?: string;           // 썸네일 URL
      oimgurl?: string;       // 원본 이미지 URL
      org_title?: string;     // 제목
      docurl?: string;        // 출처 페이지 URL
      width?: number;
      height?: number;
      display_cpname?: string; // 출처 사이트명
    }> = [];

    // 정규식으로 개별 이미지 객체 추출 (더 안정적인 방식)
    // 각 이미지 객체: { ndid64: "...", url: "...", oimgurl: "...", org_title: "...", ... }
    const imageObjectPattern = /\{\s*ndid64:\s*"[^"]+",[\s\S]*?oimgurl:\s*"([^"]+)"[\s\S]*?org_title:\s*"([^"]*)"[\s\S]*?docurl:\s*"([^"]*)"[\s\S]*?url:\s*"([^"]+)"[\s\S]*?display_cpname:\s*"([^"]*)"/g;

    // 대체 패턴: url이 먼저 나오는 경우
    const altImagePattern = /\{\s*ndid64:\s*"[^"]+",\s*docid:[^,]+,\s*[^}]*url:\s*"([^"]+)"[^}]*oimgurl:\s*"([^"]+)"[^}]*org_title:\s*"([^"]*)"[^}]*docurl:\s*"([^"]*)"[^}]*display_cpname:\s*"([^"]*)"/g;

    let match;

    // 패턴 1: oimgurl이 url 뒤에 나오는 경우
    while ((match = imageObjectPattern.exec(html)) !== null && imageData.length < 20) {
      const [, oimgurl, org_title, docurl, url, display_cpname] = match;
      imageData.push({
        url,
        oimgurl,
        org_title: org_title.replace(/<[^>]+>/g, ''), // HTML 태그 제거
        docurl,
        display_cpname: display_cpname.replace(/&gt;/g, '>'),
      });
    }

    // 패턴 2: 대체 순서
    if (imageData.length === 0) {
      while ((match = altImagePattern.exec(html)) !== null && imageData.length < 20) {
        const [, url, oimgurl, org_title, docurl, display_cpname] = match;
        imageData.push({
          url,
          oimgurl,
          org_title: org_title.replace(/<[^>]+>/g, ''),
          docurl,
          display_cpname: display_cpname.replace(/&gt;/g, '>'),
        });
      }
    }

    // 패턴 3: 더 간단한 패턴 - url과 oimgurl만 추출
    if (imageData.length === 0) {
      const simplePattern = /url:\s*"(https?:\/\/[^"]+)"[^}]*oimgurl:\s*"(https?:\/\/[^"]+)"/g;
      while ((match = simplePattern.exec(html)) !== null && imageData.length < 20) {
        const [, url, oimgurl] = match;
        if (url.includes('kakaocdn') || url.includes('daumcdn')) {
          imageData.push({ url, oimgurl });
        }
      }
    }

    console.log(`[Daum Image Search] Extracted ${imageData.length} images using regex patterns`);


    if (imageData.length > 0) {
      imageData.slice(0, 20).forEach((img, index) => {
        const title = img.org_title || `이미지 ${index + 1}`;
        const imageUrl = img.oimgurl || img.url;
        const thumbnailUrl = img.url;

        if (imageUrl) {
          items.push({
            id: `image-${Date.now()}-${index}`,
            title: title,
            description: img.display_cpname ? `출처: ${img.display_cpname}` : '이미지',
            url: img.docurl || '',
            imageUrl: imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl,
            category: '이미지',
            metadata: {
              thumbnailUrl: thumbnailUrl?.startsWith('//') ? `https:${thumbnailUrl}` : thumbnailUrl,
              originalUrl: img.oimgurl?.startsWith('//') ? `https:${img.oimgurl}` : img.oimgurl,
              width: img.width,
              height: img.height,
              source: img.display_cpname,
            },
          });
        }
      });
    } else {
      console.log('[Daum Image Search] initialData not found, trying alternative extraction');

      // 폴백: HTML에서 이미지 태그 파싱
      const $ = cheerio.load(html);
      $('.thumb_img, .img_thumb, .c-item-content img, .wrap_thumb img').each((index, el) => {
        if (index >= 20) return;

        const $img = $(el);
        const imageUrl = $img.attr('data-original-src') || $img.attr('src') || '';
        const title = $img.attr('alt') || `이미지 ${index + 1}`;
        const $link = $img.closest('a');
        const docUrl = $link.attr('href') || '';

        if (imageUrl && !imageUrl.includes('data:image') && !imageUrl.includes('plazy')) {
          items.push({
            id: `image-fb-${Date.now()}-${index}`,
            title,
            description: '이미지',
            url: docUrl,
            imageUrl: imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl,
            category: '이미지',
            metadata: {},
          });
        }
      });
    }
  } catch (error) {
    console.error('[Daum Image Search] Error extracting images:', error);
  }

  console.log(`[Daum Image Search] Extracted ${items.length} image items`);
  return items;
}

// 컴포넌트 타입 감지
function detectComponentType($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): string {
  const className = $comp.attr('class') || '';
  const dataType = $comp.attr('data-type') || '';
  const dispAttr = $comp.attr('disp-attr') || '';  // 다음 검색 고유 속성
  const id = $comp.attr('id') || '';
  const combined = (className + ' ' + dataType + ' ' + id + ' ' + dispAttr).toLowerCase();

  // 섹션 제목도 확인
  const sectionTitle = $comp.find('.tit_comp, .tit_head, .tit_g, h3, h2').first().text().toLowerCase();
  const allText = combined + ' ' + sectionTitle;

  // 다음 검색 disp-attr 기반 타입 감지 (가장 정확)
  if (dispAttr === 'PRF') return 'people';  // Profile
  if (dispAttr === 'DNS') return 'news';     // News
  if (dispAttr === 'SNY' || dispAttr === '0NS' || dispAttr === 'SNP') return 'products'; // Shopping (SNY: 쇼핑, 0NS: 네이버쇼핑광고, SNP: 쇼핑하우)
  if (dispAttr === 'IIM') return 'images';   // Images
  if (dispAttr === 'VOI') return 'videos';   // Videos
  if (dispAttr === 'Z6T') return 'exchange'; // Exchange Rate (환율)
  if (dispAttr === '3DV') return 'country';  // Country Info (국가 정보)
  if (dispAttr === 'TCS') return 'events';   // 통합 축제/일정 정보 (TCS: 통합컬렉션)
  if (dispAttr === 'TWA' || dispAttr === 'TWD') return 'web';  // 통합웹

  // ID 기반 감지
  if (id === 'tcsColl' || id === 'tcscoll') return 'events';

  // 텍스트 기반 타입 감지 (폴백, products 제외 - SNY 없으면 쇼핑 아님)
  if (allText.includes('person') || allText.includes('인물') || allText.includes('프로필')) return 'people';
  if (allText.includes('news') || allText.includes('뉴스')) return 'news';
  // 쇼핑/상품은 disp-attr="SNY" 에서만 감지 (텍스트에 '쇼핑'이 있어도 무시)
  if (allText.includes('place') || allText.includes('장소') || allText.includes('맛집') || allText.includes('지도')) return 'locations';
  if (allText.includes('weather') || allText.includes('날씨')) return 'weather';
  if (allText.includes('환율') || allText.includes('exchange') || allText.includes('달러') || allText.includes('엔화')) return 'exchange';
  if (allText.includes('image') || allText.includes('이미지')) return 'images';
  if (allText.includes('video') || allText.includes('동영상')) return 'videos';
  if (allText.includes('blog') || allText.includes('블로그')) return 'blog';
  if (allText.includes('cafe') || allText.includes('카페글')) return 'cafe';
  if (allText.includes('web') || allText.includes('웹문서')) return 'web';
  if (allText.includes('지식') || allText.includes('답변')) return 'knowledge';

  return 'mixed';
}

// 인물 정보 추출
function extractPersonItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  // 인물 프로필 카드
  const name = $comp.find('.tit_info, .txt_name, .tit_item').first().text().trim();
  const imageUrl = $comp.find('img').first().attr('src') || '';
  const description = $comp.find('.desc, .txt_info, .cont_info').first().text().trim();

  if (name) {
    const metadata: Record<string, any> = {};

    // 상세 정보 추출
    $comp.find('.list_info li, .info_item, .txt_cont').each((_, el) => {
      const text = $(el).text().trim();
      if (text.includes('출생')) metadata.birthDate = text.replace('출생', '').trim();
      if (text.includes('직업')) metadata.occupation = text.replace('직업', '').trim();
      if (text.includes('소속')) metadata.organization = text.replace('소속', '').trim();
      if (text.includes('학력')) metadata.education = text.replace('학력', '').trim();
    });

    items.push({
      id: `person-${Date.now()}`,
      title: name,
      description: description || `${name}에 대한 정보`,
      url: $comp.find('a').first().attr('href') || '',
      imageUrl: imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl,
      category: '인물',
      metadata,
    });
  }

  return items;
}

// 뉴스 항목 추출
function extractNewsItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  // 다음 검색 뉴스 구조: .c-list-basic > li[data-docid]
  $comp.find('.c-list-basic > li[data-docid], .wrap_cont, .cont_thumb, .item_news, .news_item').each((index, el) => {
    if (index >= 5) return; // 최대 5개

    const $item = $(el);

    // 다음 검색 뉴스 구조에서 제목 추출 (언론사 이름이 아닌 실제 뉴스 제목)
    let title = $item.find('.item-title .tit-g, .tit-g.clamp-g').first().text().trim();
    if (!title) {
      title = $item.find('.tit_news, .tit, a.link_txt').first().text().trim();
    }

    // 설명 추출
    let description = $item.find('.conts-desc, .item-contents p').first().text().trim();
    if (!description) {
      description = $item.find('.desc, .txt_sub').first().text().trim();
    }

    // URL 추출 (뉴스 링크)
    let url = $item.find('.item-title a, .c-item-content a').first().attr('href') || '';
    if (!url) {
      url = $item.find('a').first().attr('href') || '';
    }

    // 이미지 URL 추출
    let imageUrl = $item.find('.item-thumb img').first().attr('data-original-src') || '';
    if (!imageUrl) {
      imageUrl = $item.find('img').first().attr('data-original-src') || $item.find('img').first().attr('src') || '';
    }

    // 언론사 추출 (c-tit-doc 내의 tit_item)
    const source = $item.find('.c-tit-doc .tit_item .txt_info, .c-tit-doc .tit_item, .info_news, .txt_cp').first().text().trim();

    // 시간 추출
    let timestamp = $item.find('.gem-subinfo .txt_info').first().text().trim();
    if (!timestamp) {
      timestamp = $item.find('.txt_time, .date, .time').first().text().trim();
    }

    if (title && title.length > 5) {
      items.push({
        id: `news-${Date.now()}-${index}`,
        title,
        description: description || title,
        url,
        imageUrl: imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl || undefined,
        category: '뉴스',
        timestamp,
        metadata: { source },
      });
    }
  });

  return items;
}

// 쇼핑 항목 추출 (SNP 쇼핑하우 + 0NS 네이버쇼핑 대응)
function extractShoppingItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];
  const dispAttr = $comp.attr('disp-attr') || '';

  // SNP (쇼핑하우) 구조: .list_shopping > li > .item_shopping
  if (dispAttr === 'SNP' || $comp.find('.list_shopping').length > 0) {
    $comp.find('.list_shopping > li, .item_shopping').each((index, el) => {
      if (index >= 10) return;

      const $item = $(el);

      // 제목 추출 (쇼핑하우 구조: .tit.clamp-g)
      const title = $item.find('.tit.clamp-g, .wrap_tit strong.tit').first().text().trim();

      // 가격 추출 (.item_price .txt_price)
      const priceText = $item.find('.item_price .txt_price, em.txt_price').first().text().trim();
      const priceMatch = priceText.replace(/[^0-9]/g, '');
      const price = priceMatch ? parseInt(priceMatch) : undefined;

      // 링크 추출
      const url = $item.find('a.thumb_bf, a.link_info').first().attr('href') || '';

      // 이미지 추출
      const $img = $item.find('.wrap_thumb img').first();
      let imageUrl = $img.attr('src') || $img.attr('data-original-src') || '';
      if (imageUrl.startsWith('//')) imageUrl = `https:${imageUrl}`;

      // 평점 추출
      const ratingText = $item.find('.ico-rate').first().text().trim();
      const rating = ratingText ? parseFloat(ratingText) : undefined;

      // 리뷰 수 추출
      const reviewText = $item.find('.txt_subinfo').first().text().trim();
      const reviewMatch = reviewText.match(/[\d,]+/);
      const reviewCount = reviewMatch ? parseInt(reviewMatch[0].replace(/,/g, '')) : undefined;

      // 배송 정보
      const deliveryText = $item.find('.txt_delivery .txt_price').first().text().trim();
      const delivery = deliveryText === '무료' ? '무료배송' : deliveryText;

      // 판매처 수
      const sellerCountText = $item.find('.txt_info').filter((_, el) => $(el).text().includes('판매처')).text().trim();
      const sellerMatch = sellerCountText.match(/[\d,]+/);
      const sellerCount = sellerMatch ? parseInt(sellerMatch[0].replace(/,/g, '')) : undefined;

      if (title && title.length > 3 && price) {
        items.push({
          id: `product-snp-${Date.now()}-${index}`,
          title,
          description: `최저가 ${price.toLocaleString()}원${sellerCount ? ` (${sellerCount}개 판매처)` : ''}`,
          url,
          imageUrl: imageUrl || undefined,
          category: '상품',
          metadata: {
            price,
            ...(rating && { rating }),
            ...(reviewCount && { reviewCount }),
            ...(delivery && { delivery }),
            ...(sellerCount && { sellerCount }),
            source: '쇼핑하우',
          },
        });
      }
    });
  }

  // 0NS (네이버 쇼핑) 구조: li > div.c-item-content
  if (items.length === 0) {
    $comp.find('li').each((index, el) => {
      if (index >= 10) return;

      const $item = $(el);
      const $content = $item.find('.c-item-content, .item_prd, .product_item');
      if ($content.length === 0 && !$item.find('.txt_price, .cont_price').length) return;

      // 제목 추출 (여러 패턴 시도)
      const title = $item.find('.tit-g.clamp-g, .tit_item, .tit_prd, .name').first().text().trim()
        || $item.find('.item-title strong').first().text().trim()
        || $item.find('a .wrap_cont .item-title').first().text().trim();

      // 가격 추출
      const priceText = $item.find('.txt_price').first().text().trim();
      const priceMatch = priceText.replace(/[^0-9]/g, '');
      const price = priceMatch ? parseInt(priceMatch) : undefined;

      // 링크 추출
      const url = $item.find('a.wrap_cont, a.thumb_bf').first().attr('href')
        || $item.find('a').first().attr('href') || '';

      // 이미지 추출 (lazy loading 대응)
      const $img = $item.find('img').first();
      let imageUrl = $img.attr('data-original-src') || $img.attr('src') || '';
      if (imageUrl.startsWith('//')) imageUrl = `https:${imageUrl}`;
      if (imageUrl.includes('data:image/gif')) imageUrl = $img.attr('data-original-src') || '';

      // 판매처 추출
      const mall = $item.find('.txt_mallname, .txt_mall, .mall').first().text().trim();

      // 배송 정보
      const delivery = $item.find('.txt_delivery').first().text().trim();

      // 리뷰 수 추출
      const reviewText = $item.find('.cont_count .txt_info, .txt_review').first().text().trim();
      const reviewMatch = reviewText.match(/[\d,]+/);
      const reviewCount = reviewMatch ? parseInt(reviewMatch[0].replace(/,/g, '')) : undefined;

      if (title && title.length > 3 && price) {
        items.push({
          id: `product-${Date.now()}-${index}`,
          title,
          description: `${mall || '쇼핑몰'}에서 판매${delivery ? ` (${delivery})` : ''}`,
          url,
          imageUrl: imageUrl || undefined,
          category: '상품',
          metadata: {
            price,
            brand: mall,
            ...(reviewCount && { reviewCount }),
            ...(delivery && { delivery }),
          },
        });
      }
    });
  }

  // 기존 패턴도 폴백으로 유지 (SNP 쇼핑하우 키워드 등)
  if (items.length === 0) {
    $comp.find('.wrap_thumb, .item_link').each((index, el) => {
      if (index >= 6) return;
      const $item = $(el);
      const title = $item.find('.txt_item, .tit_item').first().text().trim();
      const url = $item.attr('href') || $item.find('a').first().attr('href') || '';
      const imageUrl = $item.find('img').first().attr('src') || '';

      if (title && title.length > 2) {
        items.push({
          id: `product-keyword-${Date.now()}-${index}`,
          title,
          description: '쇼핑 키워드',
          url: url.startsWith('?') ? `https://search.daum.net/search${url}` : url,
          imageUrl: imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl || undefined,
          category: '상품',
          metadata: {},
        });
      }
    });
  }

  return items;
}

// 장소 항목 추출
function extractLocationItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  $comp.find('.wrap_cont, .item_place, .place_item, li').each((index, el) => {
    if (index >= 5) return;

    const $item = $(el);
    const title = $item.find('.tit_item, .name, .tit').first().text().trim();
    const address = $item.find('.txt_addr, .addr, .address').first().text().trim();
    const category = $item.find('.txt_category, .category').first().text().trim();
    const url = $item.find('a').first().attr('href') || '';
    const imageUrl = $item.find('img').first().attr('src') || '';
    const rating = $item.find('.txt_grade, .rating, .star').first().text().trim();

    if (title && title.length > 2) {
      // 실제 평점 파싱 (없으면 undefined)
      const ratingMatch = rating.match(/[\d.]+/);
      const parsedRating = ratingMatch ? parseFloat(ratingMatch[0]) : undefined;

      items.push({
        id: `location-${Date.now()}-${index}`,
        title,
        description: address || category || `${title} 정보`,
        url,
        imageUrl: imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl || undefined,
        category: category || '장소',
        metadata: {
          address,
          ...(parsedRating && { rating: parsedRating }),
        },
      });
    }
  });

  return items;
}

// 환율 정보 추출
function extractExchangeRateItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  // 통화 코드 -> 이름 매핑
  const currencyNames: Record<string, string> = {
    USD: '미국 달러',
    EUR: '유로',
    JPY: '일본 엔',
    CNY: '중국 위안',
    GBP: '영국 파운드',
    AUD: '호주 달러',
    CAD: '캐나다 달러',
    CHF: '스위스 프랑',
    HKD: '홍콩 달러',
    SGD: '싱가포르 달러',
    THB: '태국 바트',
    TWD: '대만 달러',
  };

  // 다음 검색 환율 데이터는 JavaScript 객체로 제공됨
  // nationMap 변수에서 데이터 추출 시도
  const scriptContent = $comp.find('script').text() || $comp.html() || '';

  // nationMap에서 환율 데이터 추출
  const nationMapMatch = scriptContent.match(/nationMap\s*=\s*(\{[\s\S]*?\});/);
  if (nationMapMatch) {
    try {
      // JSON 파싱을 위해 문자열 정리
      const jsonStr = nationMapMatch[1]
        .replace(/'/g, '"')
        .replace(/(\w+):/g, '"$1":')
        .replace(/,\s*}/g, '}');
      const nationMap = JSON.parse(jsonStr);

      // 주요 통화 추출
      const mainCurrencies = ['USD', 'JPY', 'EUR', 'CNY', 'GBP', 'AUD'];
      mainCurrencies.forEach((code, index) => {
        const data = nationMap[code];
        if (data) {
          items.push({
            id: `exchange-${Date.now()}-${index}`,
            title: code,
            description: currencyNames[code] || code,
            category: '환율',
            metadata: {
              currencyCode: code,
              currencyName: currencyNames[code] || code,
              baseRate: parseFloat(data.currentRate?.replace(/,/g, '') || '0'),
              cashBuy: parseFloat(data.cashBuy?.replace(/,/g, '') || '0'),
              cashSell: parseFloat(data.cashSell?.replace(/,/g, '') || '0'),
              sendRate: parseFloat(data.onlineSend?.replace(/,/g, '') || '0'),
              receiveRate: parseFloat(data.onlineRcv?.replace(/,/g, '') || '0'),
              change: parseFloat(data.currentRatio?.replace(/,/g, '') || '0'),
              changePercent: parseFloat(data.currentRatioPercent?.replace(/,/g, '') || '0'),
              trend: data.currentRatio?.startsWith('-') ? 'down' : data.currentRatio === '0' ? 'unchanged' : 'up',
            },
          });
        }
      });
    } catch (e) {
      console.log('[Exchange Rate] Failed to parse nationMap:', e);
    }
  }

  // 폴백: 텍스트에서 환율 정보 추출
  if (items.length === 0) {
    // 환율 테이블이나 리스트에서 추출
    $comp.find('.exchange_item, .rate_item, li, tr').each((index, el) => {
      if (index >= 6) return;

      const $item = $(el);
      const text = $item.text();

      // USD, JPY 등 통화 코드 찾기
      const currencyMatch = text.match(/\b(USD|EUR|JPY|CNY|GBP|AUD|CAD|CHF)\b/);
      if (!currencyMatch) return;

      const code = currencyMatch[1];

      // 숫자 추출 (환율 값)
      const rateMatch = text.match(/[\d,]+\.?\d*/g);
      const rates = rateMatch ? rateMatch.map(r => parseFloat(r.replace(/,/g, ''))) : [];

      if (rates.length > 0) {
        items.push({
          id: `exchange-${Date.now()}-${index}`,
          title: code,
          description: currencyNames[code] || code,
          category: '환율',
          metadata: {
            currencyCode: code,
            currencyName: currencyNames[code] || code,
            baseRate: rates[0],
            cashBuy: rates[1],
            cashSell: rates[2],
          },
        });
      }
    });
  }

  // 여전히 없으면 주요 통화 플레이스홀더 생성
  if (items.length === 0) {
    const mainCurrencies = [
      { code: 'USD', name: '미국 달러' },
      { code: 'JPY', name: '일본 엔 (100엔)' },
      { code: 'EUR', name: '유로' },
      { code: 'CNY', name: '중국 위안' },
    ];

    mainCurrencies.forEach((currency, index) => {
      items.push({
        id: `exchange-${Date.now()}-${index}`,
        title: currency.code,
        description: currency.name,
        category: '환율',
        metadata: {
          currencyCode: currency.code,
          currencyName: currency.name,
        },
      });
    });
  }

  return items;
}

// 국가 정보 추출 (disp-attr="3DV")
function extractCountryItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  // 국가명 추출 (다음 검색 3DV 구조: .tit-g.clamp-g)
  let countryName = $comp.find('.tit-g.clamp-g').first().text().trim();
  if (!countryName) {
    countryName = $comp.find('.tit_head, .tit_comp, h2, h3').first().text().trim();
  }
  if (!countryName) return items;

  console.log('[Country Extract] Found country name:', countryName);

  // 국가 코드 매핑
  const countryCodeMap: Record<string, string> = {
    '미국': 'US', '미합중국': 'US', 'United States': 'US',
    '일본': 'JP', '영국': 'GB', '독일': 'DE', '프랑스': 'FR',
    '중국': 'CN', '호주': 'AU', '캐나다': 'CA', '이탈리아': 'IT',
    '스페인': 'ES', '브라질': 'BR', '인도': 'IN', '러시아': 'RU',
    '대한민국': 'KR', '한국': 'KR', '멕시코': 'MX', '태국': 'TH',
    '베트남': 'VN', '필리핀': 'PH', '싱가포르': 'SG', '말레이시아': 'MY',
    '네덜란드': 'NL', '스위스': 'CH', '벨기에': 'BE', '스웨덴': 'SE',
    '노르웨이': 'NO', '덴마크': 'DK', '핀란드': 'FI', '폴란드': 'PL',
    '체코': 'CZ', '오스트리아': 'AT', '그리스': 'GR', '포르투갈': 'PT',
  };

  const countryCode = countryCodeMap[countryName] || '';

  // 국가 정보 메타데이터
  const metadata: Record<string, unknown> = {
    countryCode,
  };

  // 영문명/부가정보 추출 (sub_header의 txt-split)
  const subInfoTexts: string[] = [];
  $comp.find('.sub_header .txt-split, .conts-combo .txt-split').each((_, el) => {
    const text = $(el).text().trim();
    if (text) subInfoTexts.push(text);
  });
  if (subInfoTexts.length > 0) {
    // 첫 번째가 "북미의 국가" 같은 지역 정보, 두 번째가 영문명
    if (subInfoTexts.length >= 2) {
      metadata.region = subInfoTexts[0];
      metadata.englishName = subInfoTexts[1];
    } else {
      metadata.region = subInfoTexts[0];
    }
  }

  // dl.conts-richx에서 dt/dd 쌍으로 데이터 추출 (다음 검색 실제 구조)
  $comp.find('dl.conts-richx').each((_, dl) => {
    const $dl = $(dl);
    let currentLabel = '';

    $dl.children().each((_, el) => {
      const $el = $(el);
      const tagName = el.tagName?.toLowerCase();

      if (tagName === 'dt') {
        currentLabel = $el.text().trim();
      } else if (tagName === 'dd' && currentLabel) {
        const value = $el.text().trim();
        console.log(`[Country Extract] ${currentLabel}: ${value}`);

        switch (currentLabel) {
          case '수도': metadata.capital = value; break;
          case '인구': metadata.population = value; break;
          case '면적': metadata.area = value; break;
          case 'GDP': metadata.gdp = value; break;
          case '언어': metadata.language = value; break;
          case '통화': metadata.currency = value; break;
          case '종교': metadata.religion = value; break;
          case '기후': metadata.climate = value; break;
          case '안전': metadata.safetyInfo = value; break;
        }
        currentLabel = '';
      }
    });
  });

  // 실시간 정보 추출 (현지시간, 통화, 날씨)
  const liveInfo: Record<string, string> = {};
  $comp.find('.c-carousel .c-item-content').each((_, item) => {
    const $item = $(item);
    const label = $item.find('.tit_info').text().trim();
    const value = $item.find('.txt_info').first().text().trim();
    const subValue = $item.find('.txt_subinfo').text().trim();

    if (label && value) {
      switch (label) {
        case '현지시간':
          liveInfo.localTime = value;
          liveInfo.timeDiff = subValue;
          break;
        case '통화':
          liveInfo.exchangeRate = value;
          liveInfo.currencyUnit = subValue;
          break;
        case '날씨':
          liveInfo.weather = value;
          liveInfo.weatherDesc = subValue;
          break;
      }
    }
  });
  if (Object.keys(liveInfo).length > 0) {
    metadata.liveInfo = liveInfo;
  }

  // 설명 텍스트 추출 (q-ellipsis 내부)
  let description = $comp.find('q-ellipsis span[slot="text"]').text().trim();
  if (!description) {
    description = $comp.find('.wrap_desc').text().trim();
  }
  if (!description) {
    description = $comp.find('.desc, .txt_info').first().text().trim();
  }

  // 국기 이미지 URL 추출
  let flagUrl = $comp.find('.badge_img img').attr('data-original-src')
    || $comp.find('.badge_img img').attr('src') || '';
  if (!flagUrl) {
    flagUrl = $comp.find('img').first().attr('data-original-src')
      || $comp.find('img').first().attr('src') || '';
  }

  // URL 정리
  const url = $comp.find('.c-tit-exact a').first().attr('href') || '';
  const fullUrl = url.startsWith('//') ? `https:${url}` : url;

  console.log('[Country Extract] Metadata:', JSON.stringify(metadata, null, 2));

  items.push({
    id: `country-${Date.now()}`,
    title: countryName,
    description: description || `${countryName}에 대한 정보`,
    url: fullUrl,
    imageUrl: flagUrl.startsWith('//') ? `https:${flagUrl}` : flagUrl || undefined,
    category: '국가',
    metadata,
  });

  return items;
}

// 축제/이벤트 항목 추출 (TCS 컴포넌트 특화)
function extractEventItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  // TCS 컴포넌트의 탭 콘텐츠에서 축제 정보 추출
  // 탭 항목들 (.c-tab-content, .tab-panel 등)
  $comp.find('.c-item-content, .c-list-basic > li, .wrap_cont, li[data-docid], article').each((index, el) => {
    if (index >= 10) return; // 최대 10개

    const $item = $(el);

    // 제목 추출 (TCS 구조)
    let title = $item.find('.tit-g.clamp-g, .item-title .tit-g, .tit_news, .tit').first().text().trim();
    if (!title) {
      title = $item.find('a.link_txt, h3, h4, .txt_item').first().text().trim();
    }

    // 설명/내용 추출
    let description = $item.find('.conts-desc, .item-contents p, .desc, .txt_sub').first().text().trim();
    if (!description) {
      description = $item.find('.txt_info').first().text().trim();
    }

    // URL 추출
    let url = $item.find('.item-title a, a.wrap_cont, a').first().attr('href') || '';

    // 이미지 URL 추출 (lazy loading 대응)
    let imageUrl = $item.find('img').first().attr('data-original-src') || $item.find('img').first().attr('src') || '';
    if (imageUrl.startsWith('//')) imageUrl = `https:${imageUrl}`;
    if (imageUrl.includes('data:image/gif')) {
      imageUrl = $item.find('img').first().attr('data-original-src') || '';
      if (imageUrl.startsWith('//')) imageUrl = `https:${imageUrl}`;
    }

    // 날짜/기간 정보 추출
    let timestamp = $item.find('.gem-subinfo .txt_info, .txt_date, .date, .time').first().text().trim();
    if (!timestamp) {
      // 텍스트에서 날짜 패턴 찾기 (예: 11.14~17, 2025.11.15)
      const textContent = $item.text();
      const dateMatch = textContent.match(/\d{1,2}\.\d{1,2}[~\-]\d{1,2}|\d{4}\.\d{1,2}\.\d{1,2}/);
      if (dateMatch) timestamp = dateMatch[0];
    }

    // 장소 정보 추출
    const location = $item.find('.txt_place, .place, .location, .txt_addr').first().text().trim();

    // 출처 추출
    const source = $item.find('.c-tit-doc .tit_item, .info_news, .txt_cp, .txt_source').first().text().trim();

    // 카테고리/태그 추출
    const category = $item.find('.txt_category, .tag, .badge').first().text().trim();

    // 축제 관련 키워드가 포함된 항목 우선
    const combinedText = (title + ' ' + description).toLowerCase();
    const eventKeywords = ['축제', '페스티벌', '행사', '공연', '전시', '박람회', '마라톤', '콘서트', '불꽃', '개막', '폐막', '일정'];
    const isEventRelated = eventKeywords.some(kw => combinedText.includes(kw));

    if (title && title.length > 3 && (isEventRelated || index < 5)) {
      items.push({
        id: `event-${Date.now()}-${index}`,
        title,
        description: description || title,
        url,
        imageUrl: imageUrl || undefined,
        category: category || '축제/행사',
        timestamp,
        metadata: {
          source,
          ...(location && { location }),
          isEventRelated,
        },
      });
    }
  });

  // 축제 관련 항목을 앞으로 정렬
  items.sort((a, b) => {
    const aEvent = a.metadata?.isEventRelated ? 1 : 0;
    const bEvent = b.metadata?.isEventRelated ? 1 : 0;
    return bEvent - aEvent;
  });

  return items.slice(0, 8); // 최대 8개 반환
}

// 일반 웹문서 항목 추출
function extractWebItems($comp: cheerio.Cheerio<AnyNode>, $: cheerio.CheerioAPI): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  $comp.find('.wrap_cont, .item, li, article').each((index, el) => {
    if (index >= 5) return;

    const $item = $(el);
    const title = $item.find('.tit, .tit_item, a.link_txt, h3, h4').first().text().trim();
    const description = $item.find('.desc, .txt_info, p').first().text().trim();
    const url = $item.find('a').first().attr('href') || '';
    const imageUrl = $item.find('img').first().attr('src') || '';
    const source = $item.find('.info, .source, .txt_cp').first().text().trim();

    if (title && title.length > 5 && !title.includes('관련 검색어')) {
      items.push({
        id: `web-${Date.now()}-${index}`,
        title,
        description: description || title,
        url,
        imageUrl: imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl || undefined,
        category: source || '웹',
        timestamp: new Date().toLocaleDateString('ko-KR'),
      });
    }
  });

  return items;
}

// 환율 데이터 추출 (전체 HTML에서 nationMap 찾기)
function extractExchangeRateFromHtml(html: string): SearchResultItem[] {
  const items: SearchResultItem[] = [];

  const currencyNames: Record<string, string> = {
    USD: '미국 달러',
    EUR: '유로',
    JPY: '일본 엔 (100엔)',
    CNY: '중국 위안',
    GBP: '영국 파운드',
    AUD: '호주 달러',
  };

  // nationMap['USD'] = {...} 형식 파싱
  const mainCurrencies = ['USD', 'JPY', 'EUR', 'CNY', 'GBP', 'AUD'];

  mainCurrencies.forEach((code, index) => {
    // nationMap['USD'] = {...} 패턴 찾기
    const pattern = new RegExp(`nationMap\\['${code}'\\]\\s*=\\s*\\{([^}]+)\\}`, 's');
    const match = html.match(pattern);

    if (match) {
      const dataBlock = match[1];

      // 개별 값 추출 (rate: '1,477.00' 형식)
      const extractValue = (key: string): string => {
        const valueMatch = dataBlock.match(new RegExp(`${key}\\s*:\\s*'([^']*)'`));
        return valueMatch ? valueMatch[1] : '';
      };

      const rateStr = extractValue('rate');
      const baseRate = parseFloat(rateStr.replace(/,/g, '')) || 0;
      const change = parseFloat(extractValue('currentRatio').replace(/,/g, '')) || 0;
      const changePercentStr = extractValue('currentRatioPercent').replace('%', '');
      const changePercent = parseFloat(changePercentStr) || 0;
      const cashBuy = parseFloat(extractValue('cashBuy').replace(/,/g, '')) || 0;
      const cashSell = parseFloat(extractValue('cashSell').replace(/,/g, '')) || 0;
      const onlineSend = parseFloat(extractValue('onlineSend').replace(/,/g, '')) || 0;
      const onlineRcv = parseFloat(extractValue('onlineRcv').replace(/,/g, '')) || 0;
      const country = extractValue('country');
      const unit = extractValue('unit');
      const upDownTxt = extractValue('currentUpDownTxt');

      // description 생성 (중복 방지)
      let displayName = currencyNames[code] || code;
      if (country && unit && country !== unit) {
        displayName = `${country} ${unit}`;
      } else if (country) {
        displayName = country;
      }

      // JPY는 100엔 기준으로 표시 (rate가 1엔 기준이면 100배)
      const displayRate = code === 'JPY' && baseRate < 100 ? baseRate * 100 : baseRate;

      if (baseRate > 0) {
        items.push({
          id: `exchange-${Date.now()}-${index}`,
          title: code,
          description: code === 'JPY' ? '일본 엔 (100엔)' : displayName,
          category: '환율',
          url: extractValue('url') || undefined,
          metadata: {
            currencyCode: code,
            currencyName: code === 'JPY' ? '일본 엔 (100엔)' : displayName,
            baseRate: displayRate,
            cashBuy: cashBuy || undefined,
            cashSell: cashSell || undefined,
            sendRate: onlineSend || undefined,
            receiveRate: onlineRcv || undefined,
            change,
            changePercent,
            trend: upDownTxt === '하락' ? 'down' : upDownTxt === '상승' ? 'up' : change < 0 ? 'down' : change > 0 ? 'up' : 'unchanged',
          },
        });
      }
    }
  });

  console.log(`[Exchange Rate] Extracted ${items.length} currencies from HTML`);
  return items;
}

// 환율 폴백 데이터 생성 (환율 관련 쿼리에만 사용)
function createExchangeRateFallback(): SearchResultItem[] {
  console.log('[Exchange Rate] Using fallback placeholder data');
  const defaultRates = [
    { code: 'USD', name: '미국 달러', rate: 1400, change: 5.00 },
    { code: 'JPY', name: '일본 엔 (100엔)', rate: 920, change: -2.50 },
    { code: 'EUR', name: '유로', rate: 1530, change: 3.20 },
    { code: 'CNY', name: '중국 위안', rate: 193, change: 0.80 },
  ];

  return defaultRates.map((currency, index) => ({
    id: `exchange-fallback-${Date.now()}-${index}`,
    title: currency.code,
    description: currency.name,
    category: '환율',
    metadata: {
      currencyCode: currency.code,
      currencyName: currency.name,
      baseRate: currency.rate,
      change: currency.change,
      changePercent: (currency.change / currency.rate) * 100,
      trend: currency.change < 0 ? 'down' : currency.change > 0 ? 'up' : 'unchanged',
    },
  }));
}

// 쿼리가 환율 관련인지 확인
function isExchangeRelatedQuery(query: string): boolean {
  const keywords = ['환율', '달러', '엔화', '유로', '위안', '환전', 'usd', 'jpy', 'eur', 'cny'];
  const q = query.toLowerCase();
  return keywords.some(kw => q.includes(kw));
}

// HTML에서 g_comp 컴포넌트 및 검색 결과 추출
function extractComponents(html: string, query: string): DaumSearchComponent[] {
  const $ = cheerio.load(html);
  const components: DaumSearchComponent[] = [];

  // 먼저 환율 데이터 추출 시도 (특별 처리)
  let exchangeItems = extractExchangeRateFromHtml(html);

  // 환율 관련 쿼리인데 데이터를 못 찾으면 폴백 사용
  if (exchangeItems.length === 0 && isExchangeRelatedQuery(query)) {
    exchangeItems = createExchangeRateFallback();
  }

  if (exchangeItems.length > 0) {
    components.push({
      type: 'exchange',
      title: '실시간 환율',
      items: exchangeItems,
      raw: `환율 정보: ${exchangeItems.map(i => `${i.title}=${i.metadata?.baseRate}`).join(', ')}`,
    });
  }

  // #exchangeColl 또는 disp-attr="Z6T" 확인
  const $exchangeColl = $('#exchangeColl, [disp-attr="Z6T"]');
  if ($exchangeColl.length > 0 && exchangeItems.length === 0) {
    // 폴백: exchangeColl 요소에서 텍스트 추출
    const items = extractExchangeRateItems($exchangeColl, $);
    if (items.length > 0) {
      components.push({
        type: 'exchange',
        title: '실시간 환율',
        items,
        raw: $exchangeColl.text().slice(0, 500),
      });
    }
  }

  // #tcsColl 또는 disp-attr="TCS" 확인 (축제/일정 통합 컬렉션)
  const $tcsColl = $('#tcsColl, [disp-attr="TCS"]');
  if ($tcsColl.length > 0) {
    console.log('[Daum Search] Found TCS collection');
    const items = extractEventItems($tcsColl, $);
    const rawText = $tcsColl.text().replace(/\s+/g, ' ').trim().slice(0, 1000);

    // 이미지 URL 추출
    const imageUrls: string[] = [];
    $tcsColl.find('img').each((_, img) => {
      const src = $(img).attr('data-original-src') || $(img).attr('src') || '';
      if (src && !src.includes('plazy.svg') && !src.includes('icon')) {
        const fullSrc = src.startsWith('//') ? `https:${src}` : src;
        if (!imageUrls.includes(fullSrc)) imageUrls.push(fullSrc);
      }
    });

    components.push({
      type: 'events',
      title: '축제/일정 정보',
      items,
      raw: `${rawText}\n[이미지URLs]: ${imageUrls.slice(0, 5).join(', ')}`,
    });
  }

  $('.g_comp').each((index, element) => {
    const $comp = $(element);
    const className = $comp.attr('class') || '';
    const dataType = $comp.attr('data-type') || '';

    // 관련 검색어 제외
    if (
      className.includes('relate') ||
      dataType.includes('relate') ||
      $comp.find('.tit_relate').length > 0 ||
      $comp.text().includes('관련 검색어')
    ) {
      return;
    }

    const type = detectComponentType($comp, $);
    const sectionTitle = $comp.find('.tit_comp, .tit_head, .tit_g, h3, h2').first().text().trim() || type;

    // 타입별 항목 추출
    let items: SearchResultItem[] = [];
    switch (type) {
      case 'people':
        items = extractPersonItems($comp, $);
        break;
      case 'news':
        items = extractNewsItems($comp, $);
        break;
      case 'products':
        items = extractShoppingItems($comp, $);
        break;
      case 'locations':
        items = extractLocationItems($comp, $);
        break;
      case 'exchange':
        items = extractExchangeRateItems($comp, $);
        break;
      case 'country':
        items = extractCountryItems($comp, $);
        break;
      case 'events':
        items = extractEventItems($comp, $);
        break;
      default:
        items = extractWebItems($comp, $);
    }

    // raw 텍스트 + 이미지 URL 추출
    const rawText = $comp.text().replace(/\s+/g, ' ').trim().slice(0, 500);

    // 컴포넌트 내 모든 이미지 URL 추출
    const imageUrls: string[] = [];
    $comp.find('img').each((_, img) => {
      const src = $(img).attr('data-original-src') || $(img).attr('src') || '';
      if (src && !src.includes('plazy.svg') && !src.includes('icon')) {
        const fullSrc = src.startsWith('//') ? `https:${src}` : src;
        if (!imageUrls.includes(fullSrc)) {
          imageUrls.push(fullSrc);
        }
      }
    });

    // 컴포넌트 내 모든 링크 URL 추출
    const linkUrls: string[] = [];
    $comp.find('a[href]').each((_, a) => {
      const href = $(a).attr('href') || '';
      if (href && href.startsWith('http')) {
        linkUrls.push(href);
      }
    });

    // raw에 이미지/링크 정보 포함
    const raw = `${rawText}\n[이미지URLs]: ${imageUrls.slice(0, 5).join(', ')}\n[링크URLs]: ${linkUrls.slice(0, 3).join(', ')}`;

    if (items.length > 0 || rawText.length > 30) {
      // 각 아이템에 소스 의도 추가
      items.forEach(item => {
        item.metadata = { ...item.metadata, sourceIntent: type };
      });

      components.push({
        type,
        title: sectionTitle,
        items,
        raw,
      });
    }
  });

  return components;
}

// LLM으로 g_comp raw 데이터를 SearchResultItem 구조로 추출
async function extractStructuredDataWithLLM(
  query: string,
  components: DaumSearchComponent[],
  searchIntent?: string  // 검색 의도 힌트
): Promise<SearchResultItem[]> {
  if (!process.env.OPENAI_API_KEY || components.length === 0) {
    return [];
  }

  // 인물 검색인 경우 더 많은 컴포넌트에서 정보 추출 (PRF 섹션이 비어있을 수 있음)
  const isPeopleSearch = searchIntent === 'people' ||
    components.some(c => c.type === 'people') ||
    /[가-힣]{2,4}$/.test(query.trim()); // 한글 이름 패턴

  // 축제/이벤트 검색인지 확인
  const eventKeywords = ['축제', '페스티벌', '일정', '행사', '이벤트', '공연', '전시', '박람회'];
  const isEventSearch = searchIntent === 'events' ||
    components.some(c => c.type === 'events') ||
    eventKeywords.some(kw => query.includes(kw));

  const componentCount = (isPeopleSearch || isEventSearch) ? 4 : 2;
  const topComponents = components.slice(0, componentCount);

  // 유효한 컴포넌트만 필터링 (raw 텍스트가 있는 것)
  const validComponents = topComponents.filter(c => c.raw && c.raw.length > 50);

  if (validComponents.length === 0) {
    console.log('[LLM Extract] No valid components with content');
    return [];
  }

  const rawContents = validComponents.map((c, idx) =>
    `[컴포넌트 ${idx + 1}: ${c.type}] ${c.title}\n원본 텍스트:\n${c.raw.slice(0, 1500)}`
  ).join('\n\n---\n\n');

  // 인물 검색 특화 프롬프트
  const personPrompt = isPeopleSearch ? `
## 인물 검색 특별 지침
검색어 "${query}"는 인물 검색입니다. 다음을 수행하세요:
1. **첫 번째 항목으로 인물 프로필 카드를 생성**:
   - title: 인물 이름
   - category: "인물"
   - description: 직업/소속/대표작 요약
   - metadata에 occupation, organization 등 포함
2. 뉴스/기사에서 인물에 대한 최신 정보 추출
3. 인물과 직접 관련된 정보만 포함` : '';

  // 축제/이벤트 검색 특화 프롬프트
  const eventPrompt = isEventSearch ? `
## 축제/이벤트 검색 특별 지침
검색어 "${query}"는 축제/이벤트 검색입니다. 다음을 수행하세요:
1. **축제/행사 정보를 타임라인 형식으로 추출**:
   - title: 축제/행사 이름 (예: "2025 구미 라면축제")
   - category: "축제" 또는 "행사"
   - timestamp: 개최 기간 (예: "11.14~17", "2025.11.15~16")
   - description: 간단한 설명 또는 특징
   - metadata에 location(장소), source(출처) 포함
2. **날짜 정보가 있는 축제를 우선 추출**
3. 텍스트에서 축제명, 날짜, 장소를 정확히 파싱
4. 최대 8개까지 추출` : '';

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: `검색 결과에서 추출한 텍스트를 분석하여 구조화된 데이터로 변환하세요.
${personPrompt}
${eventPrompt}

반드시 아래 JSON 배열 형식으로만 응답하세요:
[
  {
    "title": "제목/이름 (필수)",
    "description": "설명 또는 부가정보",
    "url": "링크 URL ([링크URLs]에서 가장 관련있는 것)",
    "imageUrl": "이미지 URL ([이미지URLs]에서 가장 관련있는 것)",
    "category": "카테고리 (인물, 영화, 드라마, 뉴스, 상품 등)",
    "timestamp": "날짜 정보",
    "metadata": {
      "age": "나이 (예: 42세)",
      "birthDate": "출생일",
      "occupation": "직업 (예: 배우, 가수, 운동선수)",
      "organization": "소속사/팀",
      "spouse": "배우자",
      "source": "출처",
      "price": 가격(숫자),
      "address": "주소"
    }
  }
]

규칙:
- 최대 5개 항목만 추출 (축제/이벤트 검색은 최대 8개)
- **인물 검색인 경우**: 텍스트에서 나이, 직업, 소속, 배우자 등 인물 정보를 반드시 추출하고 첫 항목은 프로필
- **축제/이벤트 검색인 경우**: 축제명, 날짜(timestamp), 장소를 정확히 추출하고 날짜가 있는 항목 우선
- **[이미지URLs]에서 첫 번째 URL을 imageUrl로 사용**
- **[링크URLs]에서 가장 관련있는 URL을 url로 사용**
- 실제로 있는 정보만 포함 (없으면 필드 생략)
- 광고, 관련검색어 제외`,
        },
        {
          role: 'user',
          content: `검색어: "${query}"

검색 결과 원본:
${rawContents}

위 텍스트에서 주요 검색 결과를 구조화된 데이터로 추출하세요.`,
        },
      ],
      temperature: 0.1,
      max_tokens: 1200,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) return [];

    // JSON 배열 파싱
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    if (!jsonMatch) return [];

    const parsed = JSON.parse(jsonMatch[0]) as Array<{
      title: string;
      description?: string;
      url?: string;
      imageUrl?: string;
      category?: string;
      timestamp?: string;
      metadata?: Record<string, unknown>;
    }>;

    // 디버그: LLM 추출 결과 상세 로깅
    console.log('[LLM Extract] isPeopleSearch:', isPeopleSearch);
    console.log('[LLM Extract] Parsed items:', parsed.map(p => ({ title: p.title, category: p.category, metadata: p.metadata })));

    // SearchResultItem 형태로 변환
    return parsed.map((item, idx) => ({
      id: `llm-extracted-${Date.now()}-${idx}`,
      title: item.title,
      description: item.description,
      url: item.url,
      imageUrl: item.imageUrl,
      category: item.category,
      timestamp: item.timestamp,
      metadata: {
        ...item.metadata,
        sourceIntent: validComponents[0]?.type || 'mixed',
        extractedByLLM: true,
      },
    }));
  } catch (error) {
    console.error('[Daum Search] LLM data extraction error:', error);
    return [];
  }
}

// LLM으로 검색 결과 분석
async function analyzeWithLLM(query: string, components: DaumSearchComponent[]): Promise<{
  primaryIntent: SearchIntent;
  secondaryIntent?: SearchIntent;
  reasoning: string;
}> {
  // 쇼핑 컴포넌트가 있고 상품 아이템이 있으면 무조건 products 반환
  const productsComp = components.find(c => c.type === 'products');
  if (productsComp && productsComp.items.length > 0) {
    console.log(`[Daum Search] Products component found with ${productsComp.items.length} items - forcing products intent`);
    return {
      primaryIntent: 'products',
      secondaryIntent: components.find(c => c.type !== 'products')?.type as SearchIntent,
      reasoning: `쇼핑 컴포넌트(${productsComp.items.length}개 상품) 감지로 products 의도 강제 설정`,
    };
  }

  if (!process.env.OPENAI_API_KEY || components.length === 0) {
    // 폴백: 첫 번째 컴포넌트 타입 사용
    const firstType = components[0]?.type || 'mixed';
    return {
      primaryIntent: firstType as SearchIntent,
      secondaryIntent: components[1]?.type as SearchIntent,
      reasoning: `컴포넌트 기반: ${components.map(c => c.type).join(', ')}`,
    };
  }

  const componentSummary = components.slice(0, 3).map((c, i) =>
    `${i + 1}. [${c.type}] ${c.title} (${c.items.length}개 항목)`
  ).join('\n');

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: `검색 엔진 결과를 분석하여 의도를 파악합니다.
상위 컴포넌트들의 타입을 보고 주요 의도와 보조 의도를 결정하세요.

JSON으로 응답: {"primaryIntent": "타입", "secondaryIntent": "타입 또는 null", "reasoning": "이유"}`,
        },
        {
          role: 'user',
          content: `검색어: "${query}"\n\n결과:\n${componentSummary}`,
        },
      ],
      temperature: 0.1,
      max_tokens: 150,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) throw new Error('Empty');

    const parsed = JSON.parse(content.match(/\{[\s\S]*\}/)?.[0] || '{}');
    return {
      primaryIntent: parsed.primaryIntent || components[0]?.type || 'mixed',
      secondaryIntent: parsed.secondaryIntent,
      reasoning: parsed.reasoning || '분석 완료',
    };
  } catch (error) {
    console.error('[Daum Search] LLM error:', error);
    return {
      primaryIntent: components[0]?.type as SearchIntent || 'mixed',
      secondaryIntent: components[1]?.type as SearchIntent,
      reasoning: `폴백: ${components.map(c => c.type).join(', ')}`,
    };
  }
}

// 메인 함수: 다음 검색 결과 분석
export async function analyzeDaumSearch(query: string): Promise<SearchEngineAnalysis> {
  console.log('[Daum Search] Analyzing query:', query);

  try {
    // 먼저 일반 검색 결과를 가져와서 상위 컴포넌트 분석
    const html = await fetchDaumSearchHtml(query);

    // 상위 컴포넌트에서 주요 의도 판단
    const topAnalysis = analyzeTopComponents(html, query);

    // 이미지 의도인 경우 전용 이미지 검색 수행
    if (topAnalysis?.primaryIntent === 'images') {
      console.log('[Daum Search] Images intent detected - fetching dedicated image search');
      const imageHtml = await fetchDaumImageSearchHtml(query);
      const imageItems = extractImageItemsFromHtml(imageHtml);

      if (imageItems.length > 0) {
        console.log(`[Daum Search] Image search returned ${imageItems.length} images`);
        return {
          query,
          components: [{
            type: 'images',
            title: '이미지 검색 결과',
            items: imageItems,
            raw: `이미지 검색: ${imageItems.length}개 결과`,
          }],
          allItems: imageItems,
          llmExtractedItems: [],
          primaryIntent: 'images',
          reasoning: topAnalysis.reasoning,
        };
      }
      console.log('[Daum Search] Image search returned no results, continuing with normal analysis');
    }

    const components = extractComponents(html, query);
    console.log(`[Daum Search] Found ${components.length} components with ${components.reduce((sum, c) => sum + c.items.length, 0)} items`);

    // 컴포넌트 타입으로 빠른 의도 추정 (LLM 추출에 힌트로 사용)
    const hasExchangeComponent = components.some(c => c.type === 'exchange');
    const hasCountryComponent = components.some(c => c.type === 'country');
    const hasEventsComponent = components.some(c => c.type === 'events');
    const hasProductsComponent = components.some(c => c.type === 'products');
    const hasPeopleComponent = components.some(c => c.type === 'people');
    const hasNewsComponent = components.some(c => c.type === 'news');
    const quickIntent = hasExchangeComponent ? 'exchange'
      : hasCountryComponent ? 'country'
      : hasEventsComponent ? 'events'
      : hasProductsComponent ? 'products'  // 쇼핑 추가
      : hasPeopleComponent ? 'people'
      : hasNewsComponent ? 'news'
      : components[0]?.type;
    console.log('[Daum Search] Quick intent:', quickIntent);

    // 중요 컴포넌트 우선 정렬 (exchange, country, products, events, people, news 순)
    const priorityOrder: Record<string, number> = {
      'exchange': 0,  // 환율 최우선
      'country': 1,   // 국가 정보
      'products': 2,  // 쇼핑/상품 (SNP, SNY)
      'events': 3,    // 축제/이벤트
      'people': 4,
      'news': 5,
      'locations': 6,
      'weather': 7,
      'images': 8,
      'videos': 9,
      'web': 10,
      'mixed': 11,
    };
    // 환율 컴포넌트 명시적 분리 (정렬 문제 해결)
    const exchangeComps = components.filter(c => c.type === 'exchange');
    const otherComps = components.filter(c => c.type !== 'exchange');

    // 환율 컴포넌트를 맨 앞에, 나머지는 우선순위로 정렬
    const sortedOthers = otherComps.sort((a, b) => {
      const aPriority = priorityOrder[a.type] || 10;
      const bPriority = priorityOrder[b.type] || 10;
      return aPriority - bPriority;
    });

    // 환율/국가 컴포넌트를 맨 앞에 배치
    const countryComps = sortedOthers.filter(c => c.type === 'country');
    const restComps = sortedOthers.filter(c => c.type !== 'country');
    const sortedComponents = [...exchangeComps, ...countryComps, ...restComps];

    // 환율/국가/상품/이벤트/인물/뉴스 검색의 경우 더 많은 컴포넌트 사용
    const componentCount = (hasExchangeComponent || hasCountryComponent || hasProductsComponent || hasEventsComponent || hasPeopleComponent || hasNewsComponent) ? 4 : 2;
    const topComponents = sortedComponents.slice(0, componentCount);
    console.log('[Daum Search] Top components:', topComponents.map(c => `[${c.type}] ${c.title} (${c.items.length})`));

    // cheerio로 추출한 아이템
    const cheerioItems = topComponents.flatMap(c => c.items);

    // topAnalysis가 있으면 그 의도를 사용, 없으면 LLM 분석
    const effectiveIntent = topAnalysis?.primaryIntent || quickIntent;

    // LLM 데이터 구조 추출 (의도 힌트 전달)
    const llmExtractedItems = await extractStructuredDataWithLLM(query, components, effectiveIntent);

    console.log('[Daum Search] LLM extracted items:', llmExtractedItems.length);

    // cheerio 추출 아이템과 LLM 추출 아이템 병합 (LLM 우선, 중복 제거)
    const mergedItems = mergeItems(cheerioItems, llmExtractedItems);

    // 최종 의도 결정: disp-attr 기반 > 컴포넌트 기반 (단, 약한 신호는 폴백)
    // 약한 신호: web/ads 의도이거나 position >= 3인 경우
    const weakIntents = ['web', 'ads', 'mixed'];
    const strongIntents = ['products', 'news', 'people', 'images', 'exchange', 'country', 'events', 'locations', 'weather'];

    const isWeakSignal = !topAnalysis ||
      (weakIntents.includes(topAnalysis.primaryIntent) && topAnalysis.position >= 3);
    const hasStrongQuickIntent = strongIntents.includes(quickIntent || '');

    // 약한 신호이고 quickIntent가 강한 의도면 quickIntent 사용
    let finalIntent: SearchIntent;
    let finalReasoning: string;

    if (isWeakSignal && hasStrongQuickIntent) {
      finalIntent = quickIntent as SearchIntent;
      finalReasoning = `컴포넌트 분석 기반: ${quickIntent} (disp-attr 신호 약함: ${topAnalysis?.primaryIntent || 'none'} at position ${topAnalysis?.position ?? 'N/A'})`;
      console.log(`[Daum Search] Weak disp-attr signal, using quickIntent: ${quickIntent}`);
    } else {
      finalIntent = topAnalysis?.primaryIntent as SearchIntent || quickIntent as SearchIntent || 'mixed';
      finalReasoning = topAnalysis?.reasoning || `컴포넌트 기반: ${components.map(c => c.type).join(', ')}`;
    }

    console.log(`[Daum Search] Final intent: ${finalIntent} (${topAnalysis && !isWeakSignal ? 'from disp-attr' : 'from components'})`);

    return {
      query,
      components: topComponents,
      allItems: mergedItems,
      llmExtractedItems,
      primaryIntent: finalIntent,
      secondaryIntent: components[1]?.type as SearchIntent,
      reasoning: finalReasoning,
    };
  } catch (error) {
    console.error('[Daum Search] Error:', error);
    return {
      query,
      components: [],
      allItems: [],
      llmExtractedItems: [],
      primaryIntent: 'mixed',
      reasoning: '검색 실패',
    };
  }
}

// 아이템 병합 (LLM 데이터 + cheerio의 이미지/URL 보완)
function mergeItems(cheerioItems: SearchResultItem[], llmItems: SearchResultItem[]): SearchResultItem[] {
  // cheerio 아이템을 제목으로 인덱싱 (이미지/URL 조회용)
  const cheerioByTitle = new Map<string, SearchResultItem>();
  for (const item of cheerioItems) {
    cheerioByTitle.set(item.title.toLowerCase().trim(), item);
  }

  // LLM 아이템에 cheerio의 이미지/URL 정보 보완
  const enrichedLlmItems = llmItems.map(llmItem => {
    const normalizedTitle = llmItem.title.toLowerCase().trim();
    const cheerioItem = cheerioByTitle.get(normalizedTitle);

    if (cheerioItem) {
      // cheerio에서 이미지, URL 정보 가져오기
      return {
        ...llmItem,
        imageUrl: llmItem.imageUrl || cheerioItem.imageUrl,
        url: llmItem.url || cheerioItem.url,
        metadata: {
          ...cheerioItem.metadata,  // cheerio 메타데이터 먼저
          ...llmItem.metadata,      // LLM 메타데이터 덮어쓰기
        },
      };
    }
    return llmItem;
  });

  const result: SearchResultItem[] = [...enrichedLlmItems];
  const processedTitles = new Set(llmItems.map(i => i.title.toLowerCase().trim()));

  // cheerio 아이템 중 LLM에 없는 것만 추가
  for (const item of cheerioItems) {
    const normalizedTitle = item.title.toLowerCase().trim();
    if (!processedTitles.has(normalizedTitle)) {
      result.push(item);
      processedTitles.add(normalizedTitle);
    }
  }

  return result.slice(0, 10); // 최대 10개
}
